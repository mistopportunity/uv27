<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <canvas width="500" height="500" id="canvas"></canvas>
    <script>
    const canvas = document.getElementById("canvas");
    const context = canvas.getContext("2d");

    function polarInversionRenderer() {
        this.amount = 4;

        this.drawPrecision = 1;

        const radius = 0;//Math.min(canvas.width,canvas.height) * 0.5; 

        this.radiusSquared = radius * radius;

        this.xCenterOffset = canvas.width / 2;
        this.yCenterOffset = canvas.height / 2;

        const left = 100;
        const right = canvas.width - 100;

        const top = 100;
        const bottom = canvas.height - 100;


        this.process = () => {

            const sourceData = context.getImageData(0,0,canvas.width,canvas.height);

            let y = 0, x = 0, relativeX, relativeY;
            while(y < canvas.height) {
                relativeY = y - this.yCenterOffset;
                x = 0;
                while(x < canvas.width) {
                    relativeX = x - this.xCenterOffset;

                    const invertDistance = 1 + this.amount * (this.radiusSquared / (relativeX * relativeX + relativeY * relativeY) - 1);
                    const sampleX = (relativeX * invertDistance) + this.xCenterOffset;
                    const sampleY = (relativeY * invertDistance) + this.yCenterOffset;

                    let isOnSurface = false;
                    if(sampleX >= 0 && sampleX <= sourceData.width - 1 && sampleY >= 0) {
                        isOnSurface = sampleY <= sourceData.height - 1;
                    }

                    if(isOnSurface && isFinite(sampleX) && isFinite(sampleY)) {

                        const sampleIndex = (Math.round(sampleX) + (sourceData.width * Math.round(sampleY))) * 4;

                        if(sampleIndex === null) continue;
                        const destinationStart = (x + (sourceData.width * y)) * 4;

                        sourceData.data[destinationStart] = sourceData.data[sampleIndex];
                        sourceData.data[destinationStart+1] = sourceData.data[sampleIndex+1];
                        sourceData.data[destinationStart+2] = sourceData.data[sampleIndex+2];
                        sourceData.data[destinationStart+3] = sourceData.data[sampleIndex+3];
                    }
                    x+=this.drawPrecision;
                }
                y+=this.drawPrecision;
            }
            context.putImageData(sourceData,0,0);
        }
    }


    const ball = {
        x:0,
        y:0,
        horizontalVelocity: 20,
        verticalVelocity: 20,
        radius: 25
    };

    Math.PI2 = Math.PI * 2;

    const polarInversionEffect = new polarInversionRenderer();

    let animationFrame = requestAnimationFrame(updateAnimationFrame);
    function updateAnimationFrame(timestamp) {

        animationFrame = requestAnimationFrame(updateAnimationFrame);

        ball.x += ball.horizontalVelocity;
        ball.y += ball.verticalVelocity;

        if(ball.x < 0 || ball.x > canvas.width) {
            ball.horizontalVelocity = -ball.horizontalVelocity;
        }
        if(ball.y < 0 || ball.y > canvas.height) {
            ball.verticalVelocity = -ball.verticalVelocity;
        }
        
        context.fillStyle = "rgba(0,0,0,0.1)";
        context.fillRect(0,0,canvas.width,canvas.height);

        context.beginPath();
        context.fillStyle = "purple";
        context.arc(ball.x,ball.y,ball.radius,0,Math.PI2);
        context.fill();

        polarInversionEffect.process();
    }
    </script>
</body>
</html>